"""
This file containts the tests for the microtool.dmipy submodule. In this way we assert that the wrappers work as
intended.

We want to test the following aspects:


1.) Wrapping and then converting an acquisition scheme yields the same acquisition scheme.

2.) When simulating signal using dmipytissuemodelwrapper we get the same result
as simulating signal using the same pure dmipy model and scheme.


"""
import numpy as np
import pytest
from dmipy.core.modeling_framework import MultiCompartmentModel

from dmipy.data import saved_acquisition_schemes
from dmipy.signal_models import cylinder_models
from dmipy.core.acquisition_scheme import DmipyAcquisitionScheme

from microtool.dmipy import DmipyAcquisitionSchemeWrapper, DmipyTissueModel, convert_acquisition_scheme


class TestSchemeWrapping:
    """
    Here we collect all tests concerning DmipyAcquisitionSchemeWrapper and convert_acquisition_scheme
    """
    # Standard acquisition scheme from dmipy.data
    naked_scheme = saved_acquisition_schemes.wu_minn_hcp_acquisition_scheme()
    # Micrtool scheme wrapper
    wrapped_scheme = DmipyAcquisitionSchemeWrapper(naked_scheme)
    # Microtool scheme converter
    converted_wrapped_scheme = convert_acquisition_scheme(wrapped_scheme)

    def test_instance(self):
        """
        converting the acquisition scheme should yield a DmipyAcquisitionScheme
        """
        assert isinstance(self.converted_wrapped_scheme, DmipyAcquisitionScheme)

    def test_attributes(self):
        """
        Since some of the DmipyAcquisitionScheme attributes are strange objects we test here for all float,int or
        numpy array attributes to check if they are approximately equal.

        Failure of this test means there is something wrong with microtool.dmipy.DmipyAcquisitionSchemeWrapper
        """
        # going over all attributes that are python native or numpy native and asserting equality

        naked_attributes = vars(self.naked_scheme)
        converted_attributes = vars(self.converted_wrapped_scheme)
        for attribute, value in naked_attributes.items():
            report = f"The attribute {attribute} triggered an assertion, i.e., they are not equal for both " \
                     f"scheme types "
            if isinstance(value, np.ndarray):
                assert np.allclose(value, converted_attributes[attribute]), report
            elif isinstance(value, (float, int)):
                assert value == converted_attributes[attribute], report


class TestTissueModelWrapping:
    """
    Here we collected all test concerning DmipyTissueModel.__call__ method
    """
    # The pure dmipy scheme
    scheme = saved_acquisition_schemes.wu_minn_hcp_acquisition_scheme()

    # simplest tissuemodel available in dmipy
    mu = (np.pi / 2., np.pi / 2.)  # in radians
    lambda_par = 1.7e-9  # in m^2/s
    stick = cylinder_models.C1Stick(mu=mu, lambda_par=lambda_par)
    stick_model = MultiCompartmentModel(models=[stick])
    parameters = {'C1Stick_1_mu': mu, 'C1Stick_1_lambda_par': lambda_par}

    def test_simulate_signal(self):
        """
        In this test we assert that the signal as generated by MultiCompartmentModel.simulate_signal is the same as
        the DmipyTissueModel.__call__

        In otherwords if this test is passed then DmipyTissueModel.__call__ is correct
        """
        stick_model_wrapped = DmipyTissueModel(self.stick_model)
        wrapped_signal = stick_model_wrapped(self.scheme)
        naked_signal = self.stick_model.simulate_signal(self.scheme, self.parameters)
        assert np.allclose(wrapped_signal, naked_signal)


def test_model_scheme_integration():
    """
    This tests if the DmipyAcquisitionSchemeWrapper and the DmipyTissueModel work together to generate the correct signal
    the other tests should be passed before testing this, otherwise failure is guaranteed.
    """

    # Acquisition aspects
    acq_scheme = saved_acquisition_schemes.wu_minn_hcp_acquisition_scheme()
    acq_wrapped = DmipyAcquisitionSchemeWrapper(acq_scheme)

    # Tissuemodel aspects
    # simplest tissuemodel available in dmipy
    mu = (np.pi / 2., np.pi / 2.)  # in radians
    lambda_par = 1.7e-9  # in m^2/s
    stick = cylinder_models.C1Stick(mu=mu, lambda_par=lambda_par)
    stick_model = MultiCompartmentModel(models=[stick])
    stick_model_wrapped = DmipyTissueModel(stick_model)
    parameters = {'C1Stick_1_mu': mu, 'C1Stick_1_lambda_par': lambda_par}

    # signal computation
    wrapped_signal = stick_model_wrapped(acq_wrapped)
    naked_signal = stick_model.simulate_signal(acq_scheme, parameters)
    assert np.allclose(wrapped_signal, naked_signal)
